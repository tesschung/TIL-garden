# 01. 논리와 증명

---

## - 논리 (Hard Logic)

### Hard Logic (논리) vs Soft Logic (직관)

- 직관은 논리적인 '느낌'을 주는 것.
- 직관의 장점은 (익숙한 상황에서) 빠르다는 것.
- 그러나 정확하지 않다는 단점을 지니고 있다. 또한 강한 착각을 일으키기도 한다.
- 프로그래밍 언어의 표현은 모두 논리학에서 나온 것이기 때문에 이를 이해하기 위해선 **Hard Logic**이 필요하다.

| p    | q    | ~p   | p ∧ q | p ∨ q | p XOR q | p → q |
| ---- | ---- | ---- | ----- | ----- | ------- | ----- |
| T    | T    | F    | T     | T     | F       | T     |
| T    | F    | F    | F     | T     | T       | F     |
| F    | T    | T    | F     | T     | T       | T     |
| F    | F    | T    | F     | F     | F       | T     |

 

:raised_hand_with_fingers_splayed:  **p** 가 False인 경우, q가 True거나 False일 수 있기 때문에 **p → q** 는 True이다. 왜냐하면 , q의 값에 대해서는 아무것도 말하지 않기때문이다.

즉, P가 False일 경우 P는 공집합이고, 공집합은 모든 집합의 부분집합이므로 P->Q는 True가 된다.

'내 방에 있는 모든 책은 소설이다'
저 명제가 진실인지 판정을 해야하는데, 책을 다 찾아보긴 귀찮으니, 반증의 방법을 쓰려합니다.
여기서 만약 내 방에 책이 하나도 없다면?
방에 책이 없으니 소설이 아닌건 없으므로, 저 명제는 참입니다.

근데,
'내 방에 있는 모든 책은 소설이 아니다'
이것도 방에 책이 하나도 없으면 참이죠.
즉, 방에 책이 없으면 '내 방에 있는 모든 책은 소설이면서 소설이 아니다'가 참이 됩니다.
아무 '의미 없는 참인 명제'라는 말입니다.
의미가 없다는게 중요합니다.
가정이 거짓이면, 명제가 참이긴 해도 '의미없는 명제'가 되어버리는거죠.
이러한 이유로 가정이 거짓이면 명제가 참입니다.

<br/>

### 명제식

```python
∀: All, 모든 ~에 대해
∃: Exist, 어떤 ~가 존재하여

# 1. 항등법칙
p ∧ True = p
p ∨ False = p
p ∧ False = False
p ∨ True = True

# 2. 부정법칙
p ∧ ~p = False
- False ∧ ~False(True) = False
- False ∧ ~True(False) = False
- True ∧ ~True(False) = False

p ∨ ~p = True
- False ∨ ~False(True) = True
- True ∨ ~True(False) = True

# 3. 이중부정
~(~p) = p
- p가 False라면, ~(~False(True)) -> ~True(False) -> False

# 4. 멱등법칙
p ∧ p = p
- False and False = False
- True and True = True

# 5. 대우법칙
p → q = ~q → ~p
- True → False = False(True) → True(False)  

# 6. 배리법(귀류법)
p → q = (p ∧ ~q → c)
- 

# 7. 교환법칙
p ∧ q = q ∧ p
-

p ∨ q = q ∨ p
-

# 8. 결합법칙
(p ∧ q) ∧ r = p ∧ (q ∧ r)
-

(p ∨ q) ∨ r = p ∨ (q ∨ r)
-

# 9. 분배법칙
p ∧ (q ∨ r) = (p ∧ q) ∨ (p ∧ r)
-

p ∨ (q ∧ r) = (p ∨ q) ∧ (p ∨ r)
-

# 10. 드모르간 법칙
~(p ∧ q) = ~p ∨ ~q
~(p ∨ q) = ~p ∧ ~q

```

<br/>

##  - 증명

- 증명은 정확한 명제식으로 표현할 수 있는 것이어야 한다.

- 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있다.

- p → q와 p ↔ q을 혼동하지 말아야 한다.

  ```python
  - 귀납법 : 개별적인 특수한 사실이나 현상에서 그러한 사례들이 포함되는 일반적인 결론을 이끌어내는 추론 형식의 추리 방법
  # 1. 벌새는 난다.
  # 2. 독수리는 난다.
  # 3. 따라서 모든 새는 난다.
  
  - 연역법 : 이미 알고 있는 판단을 근거로 새로운 판단을 유도하는 추론이다. 여기서 이미 알고 있는 판단은 전제, 새로운 판단은 결론이다. 진리가 될 수 있는 가능성을 따지는 귀납 추론과는 달리, 명제들 간의 관계와 논리적 타당성을 따진다.
  # 1. 모든 사람은 죽는다.
  # 2. 소크라테스는 사람이다.
  # 3. 따라서 소크라테스는 죽는다.
  ```

<br/>

### 수학적 귀납법

```
- 수학적 귀납법의 기본형

1. P(1)이 참이고
2. P(n) → P(n+1)이 참이라면,
3. P(n)은 모든 자연수 n에 대하여 참이다.
```

- 많은 사람들이 P(n)이 참이라고 가정할 수 없다고 반론한다.
- 그러나 수학적 귀납법에서 필요한 것은 P(n) → P(n + 1)이 참임을 보이는 것뿐이므로 P(n)이 정말로 참일 필요는 없다.

```
- 수학적 귀납법의 강한 형태

1. P(1)이 참이고
2. P(2) ∧ P(3) ∧ P(4) ∧ …… ∧ P(n) → P(n+1)이 참이면 
3. P(n)은 모든 자연수 n에 대하여 참이다.
```

<br/>

### 수학적 귀납법을 통해 함수의 정당성을 증명하기

``` python
# 1부터 x까지의 합을 계산하는 함수

def sum(x):
    if x <= 0:
        return 0
    return x + sum(x-1)

이 함수는 다음와 같은 명제로 치환할 수 있다.
p: sum(x)가 return하는 값은 1 + 2 + …… + x의 값과 항상 같다.

# 1. P(1)이 참이다.
sum(1)은 1을 return하므로 이는 참이다.

# 2. P(n) → P(n+1)이 참이다.
sum(x)는 x + sum(x-1)의 값을 return한다.
sum(x-1)의 return 값은 1 + 2 + …… + (x - 1)과 같다고 가정했으므로,
sum(x)는 1 + 2 + …… + (x - 1) + x를 return함을 확인할 수 있다.
```

<br/>

### 귀류법

- 증명하려는 명제의 결론이 부정이라는 것을 가정하였을 때 모순되는 가정이 나온다는 것을 보여, 원래의 명제가 참인 것을 증명하는 방법이다.

  ```python
  # 소수의 개수는 무한히 많다.
  
  1. 소수의 개수가 유한한 k개라고 가정한다.
  2. 이 k개의 소수를 다 곱하고 거기에 1을 더한 수를 n이라고 한다.
    n = (2 * 3 * 5 * 7 * 11 * 13 * ... * P(k)) + 1
  3. 이 수는 어떤 소수로 나누어도 나머지가 1이다.
  4. 이 n은 모든 소수보다 크므로 합성수이다. (더 이상 소수는 존재하지 않기 때문)
  5. n은 합성수이지만 어떠한 소수로도 나누어지지 않으므로 모순이 발생한다.
  
  ~p가 거짓이므로 p는 참이다. ~p = False, ~(~p) = True
  ```

<br/>

### p → q의 증명을 위한 방법 (시험에는 안 나옴)

- Direct Proof : p가 참이라고 하고 q를 증명.

- Indirect Proof : ~q가 참이라고 하고 ~p를 증명.

- Vacuous Proof : 가정이 거짓임을 증명하면 p → q는 참이다.

  ```python 
  # 1. 실수 x에 대해, 만약 2x² - 4x + 4 < 0이면 x > 8이다.
  P(x) : 2x² - 4x + 4 < 0
  Q(x) : x > 8
      
  2x² - 4x + 4 = 2(x² - 2x) + 4 = 2(x-1)² + 6
  2(x-1)² + 6 ≥ 0이므로 2x² - 4x + 4 < 0은 거짓이다.
  P(x)가 거짓이므로 P(x) → Q(x)는 참이다.
  
  # 2. 4n³ + 6n² + 11이 짝수이면 n이 홀수이다.
  4n³ + 6n² + 11 = 2(2n³ + 3n² + 5) + 1이므로 4n³ + 6n² + 11은 홀수이다.
  P(x)가 거짓이기 때문에 P(x) → Q(x)는 참이 된다.
  ```

- Trivial Proof : 결론(q)이 항상 참임을 증명.

  ```python
  # 1. 실수 x에 대해 만약 x < -1이면 x² + ¼ > 0이다.
  P(x) : x < -1
  Q(x) : x² + ¼ > 0
      
  x² + ¼ > 0, x² > -¼이고, x는 실수이므로 Q(x)는 항상 참이다.
  따라서, P(x) → Q(x)이다.
  
  # 2. n이 홀수이면 4n³ + 6n² + 12는 짝수이다.
  P(x) : n은 홀수다.
  Q(x) : 4n³ + 6n² + 12는 짝수이다.
      
  4n³ + 6n² + 12 = 2(2n³ + 3n² + 6)이므로, 4n³ + 6n² + 12는 짝수이다.
  따라서 Q(x)는 항상 참이고 P(x) → Q(x)이다.
  ```

<br/>

<br/>

---

## 연습 문제

<br/>

### 문제1. 다음 명제들이 항진명제라는 것을 진리표를 이용해 보이시오.

1. ~(~p ∧ q) ∨ q
2. (~p ∨ q) ∨ (p ∧ ~q)

### 문제2. 다음 명제들이 모순 명제라는 것을 진리표를 이용해 보이시오.

1. (~p v q) ∧ (p ∧ ~q)
2. (p ∧ q) ∧ (p ∧ ~q)

<br/>

### 문제3. 다음 명제의 쌍들에 대해서 두 명제가 동등한지를 진리표를 이용해 확인하시오.

1. p ∧ (p ∨ q)와 p
2. ~p ∨ ~q와 ~(p ∨ q)

<br/>

### 문제4. 명제식의 변형을 통하여 다음 명제를 간소화하시오.

1. (p ∧ ~q) ∨ (p ∧ q)
2. (p ∨ ~q) ∧ (~p ∨ ~q)

<br/>

### 문제5. 다음 명제들이 참인지 확인하시오. 단, R은 실수의 집합을 의미하고 , Z는 정수의 집합을 의미한다.

1. ∀x ∈ R, x² ≥ x
2. ∀x ∈ Z, x² ≥ x
3. ∃x ∈ R, x² ＜ x
4. ∃x ∈ Z, x² ＜ x

<br/>

### 문제6. n이 짝수이면 3n + 5는 홀수임을 증명하라.

<br/>

### 문제7. n이 홀수이면 n² + n은 짝수임을 증명하라.

<br/>

### 문제9. (대우를 증명) 자연수 n에 대해, n² + 5가 홀수이면 n은 짝수임을 증명하라.

<br/>

### 문제12. (대우를 증명) n²이 3의 배수이면 n도 3의 배수임을 증명하라. (★)

<br/>

<br/>

---

## 연습 문제 답

### 문제 1

1. | p    | q    | ~p   | ~p ∧ q | ~(~p ∧ q) | ~(~p ∧ q) ∨ q |
   | ---- | ---- | ---- | ------ | --------- | ------------- |
   | T    | T    | F    | F      | T         | T             |
   | T    | F    | F    | F      | T         | T             |
   | F    | T    | T    | T      | F         | T             |
   | F    | F    | T    | F      | T         | T             |

   따라서 ~(~p ∧ q) ∨ q는 항진명제다.
   
2. | p    | q    | ~p   | ~q   | ~p ∨ q | p ∧ ~q | (~p ∨ q) ∨ (p ∧ ~q) |
   | ---- | ---- | ---- | ---- | ------ | ------ | ------------------- |
   | T    | T    | F    | F    | T      | F      | T                   |
   | T    | F    | F    | T    | T      | T      | T                   |
   | F    | T    | T    | F    | T      | F      | T                   |
   | F    | F    | T    | T    | T      | F      | T                   |

   (~p ∨ q) ∨ (p ∧ ~q)가 항진명제임을 확인할 수 있다.

<br/>

### 문제2

1. | p    | q    | ~p   | ~q   | ~p ∨ q | p ∧ ~q | (~p v q) ∧ (p ∧ ~q) |
   | ---- | ---- | ---- | ---- | ------ | ------ | ------------------- |
   | T    | T    | F    | F    | T      | F      | F                   |
   | T    | F    | F    | T    | F      | T      | F                   |
   | F    | T    | T    | F    | T      | F      | F                   |
   | F    | F    | T    | T    | T      | F      | F                   |

   모든 경우에서 거짓이므로 (~p v q) ∧ (p ∧ ~q)는 모순명제다.

2. | p    | q    | ~q   | p ∧ q | p ∧ ~q | (p ∧ q) ∧ (p ∧ ~q) |
   | ---- | ---- | ---- | ----- | ------ | ------------------ |
   | T    | T    | F    | T     | F      | F                  |
   | T    | F    | T    | F     | T      | F                  |
   | F    | T    | F    | F     | F      | F                  |
   | F    | F    | T    | F     | F      | F                  |

   따라서 (p ∧ q) ∧ (p ∧ ~q)는 모순명제다.

<br/>

### 문제3

1. | p    | q    | p ∨ q | p ∧ (p ∨ q) |
   | ---- | ---- | ----- | ----------- |
   | T    | T    | T     | T           |
   | T    | F    | T     | T           |
   | F    | T    | T     | F           |
   | F    | F    | F     | F           |
   
   p와 p ∧ (p ∨ q)는 같다는 걸 확인할 수 있다.
   
2. | p    | q    | ~p   | ~q   | ~p ∨ ~q | p ∨ q | ~(p ∨ q) |
   | ---- | ---- | ---- | ---- | ------- | ----- | -------- |
   | T    | T    | F    | F    | F       | T     | F        |
   | T    | F    | F    | T    | T       | T     | F        |
   | F    | T    | T    | F    | T       | T     | F        |
   | F    | F    | T    | T    | T       | F     | T        |
   
     ~p ∨ ~q와 ~(p ∨ q)는 같지 않다.

<br/>

### 문제 4

1. ```python
   (p ∧ ~q) ∨ (p ∧ q)
   = p ∧ (~q ∨ q) # 분배법칙
   = p ∧ True # 부정법칙
   = p # 항등법칙
   ```

2. ```python
   (p ∨ ~q) ∧ (~p ∨ ~q)
   = (p ∧ ~p) ∨ ~q # 분배법칙
   = False ∨ ~q # 부정법칙
   = ~q # 항등법칙
   ```

<br/>

### 문제5

1. x = 0.1일 때 x² = 0.01로, x² < x가 되어 거짓이다.

2. ```python
   # 1. P(1)일 때
   1² = 1로, 참이다.
   
   # 2. P(n) → P(n+1)
   n이 정수일 때 |n * n| ≥ |n|이며, n² ≥ 0이므로
   n² ≥ n이 성립한다.
   n + 1 > n이고 (n + 1)² > n²이기 때문에
   (n + 1)² ≥ n + 1은 참이 된다.
   ```

3. x = 0.1일 때 x² = 0.01로, x² < x가 되는 x가 존재해 참이다.

4. 2에서 모든 정수 x가 x² ≥ x를 만족하므로 x² < x는 거짓이다.

<br/>

### 문제6

```python
p : n은 짝수다.
q : 3n + 5는 홀수다.

p가 참일 때,
n = 2k
3n + 5 = 6k + 5 = 2(3k + 2) + 1
q 역시 참임을 알 수 있다.
```

<br/>

### 문제7

```python
p : n은 홀수다.
q : n² + n은 짝수다.

p가 참일 때,
p = 2k + 1
n² + n = 4k² + 6k + 2 = 2(2k² + 3k + 1)으로,
q 또한 참이 된다.
```

<br/>

### 문제9

```python
p : n² + 5는 홀수다.
q : n은 짝수다.
~p : n² + 5는 짝수다.
~q : n은 홀수다.
    
~q가 참이라고 할 때,
n = 2k + 1 (k ≥ 0)
n² = 4k² + 4k + 1
n² + 5 = 4k² + 4k + 6 = 2(2k² + 2k + 3) ≡ 2m
따라서 ~p는 참이다.
~q → ~p가 참이므로 p → q 역시 참이다.
```

<br/>

### 문제 10

```python
p : n²은 짝수다.
q : n은 짝수다.
~p = n²은 홀수다.
~q = n은 홀수다.

~q가 참이라면,
n = 2k + 1
n² = 4k² + 4k + 1 = 2(2k² + 2k) + 1
n²도 홀수가 되어 ~p도 참이다.
~q → ~p가 참이므로, p → q도 마찬가지로 참이다.
```

<br/>

### 문제11

```python
# 1. n이 홀수인 경우
n = 2k + 1
n² + 5n + 3 = 4k² + 14k + 9 = 2(2k² + 7k + 4) + 1
따라서 n이 홀수인 경우 n² + 5n + 3 역시 홀수가 된다.

# 2. n이 짝수인 경우
n = 2k
n² + 5n + 3 = 4k² + 10k + 3 = 2(2k² + 5k + 1) + 1
n이 짝수인 경우 또한 n² + 5n + 3은 홀수임을 보일 수 있다.

n이 홀수인 경우와 짝수인 경우 모두 홀수이므로, 모든 자연수 n에 대해 n² + 5n + 3는 홀수다.
```

<br/>

### 문제12

```python
p : n²은 3의 배수이다.
q : n은 3의 배수이다.
~p : n²은 3의 배수가 아니다.
~q : n은 3의 배수가 아니다.
    
~q가 참이라면,
# 1
n = 3k + 1
n² = 9k² + 6k + 1 = 3(3k² + 2k) + 1
n²은 3의 배수가 아니다.

# 2
n = 3k + 2
n² = 9k² + 12k + 4 = 3(3k² + 4k + 1) + 1
n²은 3의 배수가 아니다.

모든 경우에서 ~p가 참이므로 ~q → ~p는 참이다.
따라서 p → q는 참이다.
```

# 복습

---



```
D F 3 7 -> D와 7을 뒤집음으로써 한쪽이 D이면 반대쪽이 3인지 확인할 수 있다
(3을 뒤집어 D가 있든 없든 상관 없다)

이는 맥주집 문제와 동일 - 17세(20세 이하가 맥주 마시면 안 됨) / 맥주(이 사람의 나이를 확인해야 함)
```



- 직관은 논리적인 느낌이므로 빠를 수 있으나 틀릴 수 있다 -> 같은 표현이어도 하나만 포함하거나 둘 다 포함하는 경우가 존재
- 프로그래밍은 Hard Logic 사용하므로 Soft Logic으로 이해하면 안 된다



ex) 명제의 참, 거짓 판별 : 앞의 명제가 거짓이면 뒤의 명제는 참, 거짓과 상관없이 명제식 자체는 참이다

반대로 앞의 명제가 참이면 뒤의 명제는 무조건 참이어야 한다

```
p -> q가 거짓(p=참, q=거짓)일 때 ~p -> q는 참(부정, 앞의 것이 참이면 참), p∨q(p나 q 중 하나만 참이면 되므로 참), q -> p(참 -> 거짓이므로 참이다)
```



```
정수 = 1, 소수, 합성수(인수분해 가능)
명제 : p -> q, 역 : q -> p, 이 : ~p -> ~q, 대우 : ~q -> ~p
```



- 진리표 -> p와 q가 T, F인 때로 나누어서 해당 명제식의 참 거짓을 판별하는 표

```
명제는 p, q 각각에 대한 T, F를 나타내며, 명제식은 여러 p, q들을 모아놓은 식이다
따라서 개별 명제가 T, F라도 명제식은 다른 결과가 나올 수 있다
진리표의 경우의 수는 문자 수^2이다
```



- 증명 : 정확한 명제식으로 표현할 수 있어야 한다

```
P(1)이 참일 때, P(n) -> P(n+1)이 참인가?
공이 2개인 경우, 첫 번째 공을 뺀 다음, 2번째 공을 다시 넣고 빼면 같은 것을 빼므로 이 명제는 참인 것처럼 느껴진다
- 귀납법의 한계
```

```python
소수 : 약수가 1과 자기 자신인 수
소수를 구하기 위해서는 2부터 루트 자기 자신까지만 반복하면 된다 = 에라토스테네스의 체

def isPrime(g):
    a = [False, False] + [True]*(g-1)
    primes = []

    for i in range(2, g+1):
        if a[i]: # True라면
            primes.append(i)
            for j in range(2*i, g+1, i):
                a[j] = False
    return a
```

```
컴퓨터로 귀납법 증명하기
P(1) = 특정한 함수에 1을 넣어 return하는 값을 확인하면 된다
P(x-1) -> P(x) = 특정한 함수에 1 ~ n-1까지 값을 넣은 경우 return한 값과 1 ~ n까지 값을 넣어 return한 값을 비교
```



- Trivial Proof

```
P -> Q를 증명하려는데, Q가 항상 참인 경우를 가리킴(뒤의 명제가 어떻든 간에 명제식은 참이다)
```



- Vacuous Proof

```
P -> Q를 증명하려는데, P가 항상 거짓인 경우를 가리킴 -> 명제식은 P가 거짓이고, Q도 거짓이므로 참이 된다
```



- 항진명제 : 항상 참이 나오는 경우(참고 : ∧ - and, ∨ - or)

| p    | q    | ~p   | ~p∧q | ~(~p∧q) | ~(~p∧q)∨ |
| ---- | ---- | ---- | ---- | ------- | -------- |
| T    | T    | F    | F    | T       | T        |
| T    | F    | F    | F    | T       | T        |
| F    | T    | T    | T    | F       | T        |
| F    | F    | T    | F    | T       | T        |





| p    | q    | ~p   | ~q   | ~p∨q | p∧~q | (~p∨q)∨(p∧~q) |
| ---- | ---- | ---- | ---- | ---- | ---- | ------------- |
| T    | T    | F    | F    | T    | F    | T             |
| T    | F    | F    | T    | F    | T    | T             |
| F    | T    | T    | F    | T    | F    | T             |
| F    | F    | T    | T    | T    | F    | T             |



- 모순명제(항상 거짓인 명제)

| p    | q    | ~p   | ~q   | ~p∨q | p∧~q | (~p∨q)∧(p∧~q) |
| ---- | ---- | ---- | ---- | ---- | ---- | ------------- |
| T    | T    | F    | F    | T    | F    | F             |
| T    | F    | F    | T    | F    | T    | F             |
| F    | T    | T    | F    | T    | F    | F             |
| F    | F    | T    | T    | T    | F    | F             |



| p    | q    | ~q   | p∧q  | p∧~q | (p∧q)∧(p∧~q) |
| ---- | ---- | ---- | ---- | ---- | ------------ |
| T    | T    | F    | T    | F    | F            |
| T    | F    | T    | F    | T    | F            |
| F    | T    | F    | F    | F    | F            |
| F    | F    | T    | F    | F    | F            |



- 두 명제가 동등한가?

| p    | q    | p∨q  | p∧(p∨q) |
| ---- | ---- | ---- | ------- |
| T    | T    | T    | T       |
| T    | F    | T    | T       |
| F    | T    | T    | F       |
| F    | F    | F    | F       |





| p    | q    | ~p   | ~q   | p∨q  | ~(p∨q) | ~p ∨ ~q |
| ---- | ---- | ---- | ---- | ---- | ------ | ------- |
| T    | T    | F    | F    | T    | F      | F       |
| T    | F    | F    | T    | T    | F      | T       |
| F    | T    | T    | F    | T    | F      | T       |
| F    | F    | T    | T    | F    | T      | T       |





- 명제 간소화하기 : U(전체 집합 = 항진명제)

```
(p ∧ ~q) ∨ (p ∧ q) = p ∧ (q ∨ ~q) = p ∧ U = p

(p ∨ ~q) ∧ (~p ∨ ~q) = (p ∧ ~p) ∨ ~q = ∮ ∨ ~q = ~q 
```



- 참, 거짓 여부 판단

```
모든 실수에서 x^2은 x보다 크거나 같다(거짓)  --- 0<x<1이 만족하지 않음
모든 정수에서 x^2은 x보다 크거나 같다(참) 
어떤 실수에서 x^2은 x보다 작다(참) --- 위 범위에서 하나라도 존재
어떤 정수에서 x^2은 x보다 작다(거짓)  --- 위 범위에서 하나라도 존재하지 않음
```



```
n이 짝수이면 3n + 5는 홀수이다
n = 2k이면 6k + 5는 2(3k + 2) + 1이므로 3n + 5는 홀수다
```



```
n이 홀수이면 n² + n은 짝수이다
n = 2k + 1이면 n² + n은 4k² + 6k + 2 = 2(2k² + 3k + 1)이므로 n² + n은 짝수이다
```



```
m이 짝수고 n이 홀수면 2m + 3n은 홀수다
m = 2k, n = 2l + 1이므로 2m + 3n은 4k + 6l + 3이므로 2(2k + 3l + 1) + 1이므로 2m + 3n은 홀수다
```



```
n이 홀수면 n² + 5는 짝수다(원래 명제가 아닌 대우를 증명)
n = 2k이면 4k² + 4k + 1 + 5 = 2(2k² + 2k + 3)이므로 n이 홀수면 n² + 5는 짝수다
```

 

```
n이 홀수면 n²은 홀수다(원래 명제의 대우를 증명)
n = 2k + 1이면 4k² + 4k + 1이므로 2(2k² + 2k) + 1이므로 n이 홀수면 n²은 홀수다
```



```
자연수 n에 대해 n² + 5n + 3은 항상 홀수다
1) n이 짝수이면 n = 2k이므로 4k² + 10k + 3이 되고, 2(2k² + 5k + 1) + 1이므로 짝수인 자연수에서 n² + 5n + 3은 항상 홀수다
2) n이 홀수면 n = 2k + 1이므로 (4k² + 4k + 1) + (10k + 5) + 3이 되고, 2(2k² + 7k + 4) + 1이므로 홀수인 자연수에서 n² + 5n + 3은 항상 홀수다
```



```
n이 3의 배수가 아니면 n²도 3의 배수가 아니다
1) n = 3k + 1이면 n² = 9k² + 6k + 1이므로 3(3k² + 2k) + 1이므로 n²은 3의 배수가 아니다
2) n = 3k + 2이면 n² = 9k² + 12k + 4이므로 3(3k² + 6k + 1) + 1이므로 n²은 3의 배수가 아니다
```



```
n이 홀수면 n²을 8로 나눈 나머지는 1이다
1) n = 4k + 1이면 n² = 16k² + 8k + 1이므로 4(4k² + 2k) + 1이므로 n²을 8로 나눈 나머지는 1이다
2) n = 4k + 3이면 n² = 16k² + 24k + 1이므로 4(4k² + 6k) + 1이므로 n²을 8로 나눈 나머지는 1이다
```



```
어떤 자연수를 제곱해도 그 결과를 3으로 나눈 나머지는 2가 아니다
1) n = 3k이면 n²
2) n = 3k + 1
3) n = 3k + 2
```



### 3. 수와 표현

1bit = 정보를 나타내는 최소의 단위

1byte = 8bit = 영문자 1자를 나타내는 단위(ASCII 코드) -> 0 ~ 127비트 -> 2byte unicode

1KB = 2^10byte 

1MB = 2^10KB

1GB = 2^10MB

1TB / 1PB / 1EB



본래 0 ~ 2ⁿ - 1의 범위를 표현할 수 있으나 부호를 표시하면 - 2 ^ (n-1)  ~ 2 ^ (n-1) -1까지만 표시 가능

어떤 값을 표현하기 위해서는 2^k >= n + 1보다 커야 한다(2^k(비트 수) - 1 >= n(표시하려는 수))

log n은 2의 몇 승이 n이 되는가에 대한 답 = n을 표현하기 위해 몇 비트가 필요한가

32비트 운영 체제 = 4GB 램만 사용 가능 <-> 64비트 운영 체제 = 8GB 램/정보량 사용 가능

따라서 64비트 운영 체제에서 32비트 프로그램을 사용 가능하나, 64비트 프로그램을 사용하면 더 빠르게 프로그램 사용 가능하다



```
log N 비트로 표현할 수 있는 숫자의 범위 : 2ⁿ가지 숫자를 표현할 수 있다
```



```
스무고개에서 최대한 맞출 수 있는 답의 종류 : 2^20 가지
```



```
2n < n²,  루트 2 < 루트 3,  2^nlogn(2^log n² = n²(2를 위로 올림)) > n!, log2 ^ 2n(=2n) < n^루트n 
```

