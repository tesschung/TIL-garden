Memoization 방법을 적용한 알고리즘
메모이제이션(memoization)은 컴퓨터 프로그램을 실행할 때 
이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. 
동적 계획법의 핵심이 되는 기술이다.
--------------------------
암기해야할 예제
--------------------------
memo를 위한 배열을 할당하고, 모두 0으로 초기화 한다;
memo[0]을 0으로 memo[1]는 1로 초기화 한다;

피보나치 수열은 DP로 풀 수 있는 문제의 대표적인 예

def fibo1(n) :
    global memo
    if n >= 2 and len(memo) <= n :
        memo.append(fibo1(n-1) + fibo1(n-2))
    return memo[n]
memo = [0, 1]
fibo1(10)
print( "메모이제이션", memo )

-------------------------------------------
동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 
그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 
최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

DP는 다음 2가지 특성을 만족해야만 사용할 수 있다.
 최적 부분문제 구조(Optimal substructure)
 중복 부분문제 구조(Overlapping subproblems)

중복 부분문제 구조(Overlapping subproblems)최적 부분문제 구조(Optimal substructure) - 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 다른
어딘가에서 필요하게 되는데(Overlapping subproblems) 이를 위해 DP에서는 이미 해결된
작은 문제들의 해들을 어떤 저장 공간(table)에 저장하게 된다.
 그리고 이렇게 저장된 해들이 다시 필요할 때마다 해를 얻기 위해 다시 문제를
재계산하지 않고 table의 참조를 통해서 중복된 계산을 피하게 된다.
최적 부분문제 구조(Optimal substructure)
주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용할 수
있다.
 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해
역시 최적이어야 한다는 것이다. 동적 계획법의 방법자체가 큰 문제의 최적 해를 작은
문제의 최적해 들을 이용하여 구하기 때문에 만약 큰 문제의 최적해가 작은 문제들의
최적화의 해들로 구성되지 않는다면 이 문제는 동적 계획법을 적용할 수 없다
3단계 DP 적용 접근 방법
1. 최적해 구조의 특성을 파악하라
- 문제를 부분 문제로 나눈다.
2. 최적해의 값을 재귀적으로 정의하라
- 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의한다.
3. 상향식 방법으로 최적해의 값을 계산하라
- 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장한다.
- 테이블에 저장되어 있는 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의
최적해를 구한다. (상향식 방법)
동적 계획 (Dynamic Programming) 알고리즘은 
그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 

 
--------------------------
암기해야할 예제
--------------------------
피보나치 수 DP 적용 알고리즘
def fibo2(n):
    f = [0, 1]
    for i in range(2, n + 1):
        f.append(f[i - 1] + f[i - 2])
    # return f[n]
    return f
print( "DP", fibo2(10) )
------------------------------------
막대기 자르기

길이(i) 0 1 2 3 4 5 6 7 8 9 10
가격(Pi) 0 1 5 8 9 10 17 17 20 24 30
예를 들면 길이가 4인 막대기를 자를 때 얻을 수 있는 최대 가격은, 
길이를 2인 막대기 두 개로 나누어서 가격을 5 + 5 = 10으로 만드는 겁니다. 
길이가 6인 막대는 자르지 않고 그냥 팔았을 때 최대 17의 가격을 얻을 수 있습니다.

이 문제는 그냥 풀기엔 좀 복잡하게 보이지만 동적 프로그래밍을 사용하면 간단하게 풀 수 있습니다.

길이가 n인 막대기의 최대 가격을 Rn이라고 했을 때, Rn = max(Pi + Rn-i) (i는 1부터 n)로 나타낼 수 있습니다. 
max는 여러 값 중의 최대값을 의미합니다. 
예를 들면 아까 길이가 4인 막대기의 최대 가격은 R4 = max(P1 + R3, P2 + R2, P3 + R1, P4 + R0)이죠.

P1, P2, P3은 이미 주어져 있습니다. 이제 R1, R2, R3을 구해야 하는데요.
R1은 Rn = max(Pi + Rn-i) (i는 1부터 n) 식에서 max(Pi + R0)이므로 1입니다.
R2는 max(P1 + R1, P2 + R0)이라 max(2, 5) = 5입니다.
R3는 max(P1 + R2, P2 + R1, P3 + R0)라서 max(6, 6, 8) = 8입니다.
R4는 위의 값들로부터 max(9, 10, 9, 9) = 10임을 알 수 있습니다.


위의 과정에서 R1, R2, R3는 계속해서 나옵니다. 
이 값들을 저장해 두고 재사용하면 일일히 재계산하지 않아도 되죠. 
바로 여기서 Top-down으로 불리는 메모이제이션을 사용할 수도 있고, 
Bottom-up이라 불리는 상향식 계산법을 사용할 수도 있습니다.

상향식 계산법이 성능이 더 좋은 경우가 많으므로 상향식 계산법을 사용하겠습니다.
--------------------------
암기해야할 예제
--------------------------
p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30];
def cutRod(p, n) :
    r = {0:0}; # r[0]=0
    for j in range(1,n+1):
        q = -1; #최대값 저장용
        for i in range(1,j+1): # r[i] = max(r[i]+r[n-i])
            q = max(q, p[i] + r[j - i]);
        r[j] = q; # r[i] = max값
    return r[n];

print(cutRod(p, 2)); # 5
print(cutRod(p, 3)); # 8
print(cutRod(p, 4)); # 10
print(cutRod(p, 7)); # 18

-------------------------------------------------
최장 공통 부분 수열 문제
def LCS(x, y) :
  i = len(x)
  j = len(y)
  result = dict();
  for k in range(i+1):
    if k not in result:
      result[k] = dict(); # 이전 계산 값 저장 공간
  for k in range(i+1):
    for l in range(j+1):
      # print(k, l);
      if k == 0 or l == 0: # 베이스 값 설정
        result[k][l] = 0;
      elif x[k - 1] == y[l - 1]: # 마지막 두 문자 비교, 같으면
        result[k][l] = result[k - 1][l - 1] + 1;
      else : # 마지막 두 문자가 다르면
        result[k][l] = max(result[k - 1][l], result[k][l - 1]);
  return result[i][j];
print(LCS('ABCBDAB', 'BDCABA')) # 4

-------------------------------------------------
0/1 배낭 문제
배낭 문제는 무게 제한이 50인 배낭에 다음과 같은 세 개의 물건을 넣는 문제입니다. 넣은 물건들의 가치(v) 합이 최대가 되면 됩니다. 문제는 세 물건의 무게(w)를 합치면 60이라 다 넣지는 못한다는 겁니다.

이 문제 이름이 0/1인 이유는 물건을 쪼개서 넣지는 못하고, 선택지가 통째로 넣거나 아예 안 넣거나 두 개밖에 없기 때문입니다.

i 	| 	1  	2  	3
------------------------------------------------
Vi	|	60	100	120
Wi	|	10	20	30
Vi/Wi	|	6	5	4

직관적으로 보면 2번과 3번 물건을 넣어서 무게는 50으로 맞추고, 가치는 220으로 하면 최적입니다. 문제는 컴퓨터한테 이 문제를 어떻게 풀도록 하냐는 거죠. 컴퓨터에게는 직관이 없습니다.

제일 먼저 떠오르는 것은 무게 대비 가치 순서로 고르도록 하는 겁니다. 이렇게 하면 1번과 2번을 선택하게 되고, 3번을 선택하지 못합니다. 틀린 결과죠.

사실 방법은 없습니다. 그냥 모든 경우를 계산해서 노가다로 푸는 겁니다. 중간에 계산 결과가 겹치는 부분은 저장해서 재사용하고요.

item = [[1, 60, 10], [2, 100, 20], [3, 120, 30]];
def zeroOneKnapsack(item, cap) :
    m = dict(); # 메모이제이션을 하는 부분
    for i in range(len(item)+1):
        m[i] = dict();
    print("m",m)
    for i in range(len(item)+1):
        for j in range(cap+1):
        # m[i][w]는 i개의 물건과 w의 무게 제한으로 가능한 최대 가치를 의미
            if i == 0 or  j == 0: # 물건이나 무게가 없음
                m[i][j] = 0; #아무 물건도 선택하지 않았거나 무게가 없는 경우
            elif item[i-1][2] > j: # 물건의 무게가 j보다 크면
          # i번째 물건의 무게가 무게 제한을 초과하는 경우는 m[i][w] = m[i-1][w]입니다.
          # 즉 마지막에 넣은 물건 하나를 다시 뺀 가치가 답이 됩니다.
                m[i][j] = m[i-1][j]
            else:
          # 초과하지 않는 경우는 m[i][w] = max(m[i-1, w], m[i-1, w-무게] +가치)입니다.
          # 마지막 물건 하나를 뺀 가치와 이전 물건을 뺀 후 새로 넣은 물건의 가치 중 큰 값을 고르면 됩니다.
                m[i][j] = max(m[i-1][j], m[i-1][j-item[i-1][2]] + item[i-1][1])
    return m[len(item)][cap];

print(zeroOneKnapsack(item, 50)) # 220