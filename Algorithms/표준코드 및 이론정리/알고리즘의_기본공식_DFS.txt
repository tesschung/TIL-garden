DFS 알고리즘
시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 
더 이상 갈 곳이 없게 되면, 
가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 
다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용 

'''
다음은 연결되어 있는 두 개의 정점 사이의 간선을 순서대로 나열 해 놓은
것이다. 모든 정점을 깊이 우선 탐색하여 화면에 깊이우선탐색 경로를
출력하시오. 시작 정점을 1로 시작하시오.
 1, 2, 1, 3, 2, 4, 2, 5, 4, 6, 5, 6, 6, 7, 3, 7
 출력 결과의 예는 다음과 같다.
– 1-2-4-6-5-7-3
– 1-3-7-6-5-2-4
'''
def DFS(v):
    # print(v)
    result.append(v) #방문하는 정점번호를 리스트에 저장
    visited[v] = True #해당정점 번호가 방문한것으로 표시

    for i in range(1, 8):
        if G[v][i] and not visited[i]: #시작번호(v)에서 i번째에 값이 있고, i번호를 방문한적 없으면
            DFS(i) # i정점 방문

edges = [1, 2, 1, 3, 2, 4, 2, 5, 4, 6, 5, 6, 6, 7, 3, 7]
result = []
visited = [0] * 8
G = [[0]* (8) for _ in range(8)] #정점간 연결정보를 저장하는 2차원 리스트

for i in range(0, len(edges), 2): #짝수번쨰가 시작정점, 그 다음 숫자는 끝정점
    G[edges[i]][edges[i+1]] = 1 #시작정점에서 끝정점을 갈 수 있음을 표시
    G[edges[i+1]][edges[i]] = 1 #끝정점에서 시작정점으로 갈 수 있음을 표시

DFS(1) #1번 정점부터 방문 시작
print("-".join( [str(i) for i in result]))

